# Table of contents
- [Table of contents](#table-of-contents)
- [Memory layout of process](#memory-layout-of-process)
- [ELF](#elf)
  - [ELF Header](#elf-header)
  - [ELF sections](#elf-sections)
    - [Initialization and termination Routines](#initialization-and-termination-routines)
    - [Relocation entries](#relocation-entries)
  - [ELF segments](#elf-segments)
- [`readelf` command](#readelf-command)
- [`strip` command](#strip-command)

<br>

# Memory layout of process
Layout for 32-bit arch:
```c
Higher Addresses
|=================| <- 0xFFFFFFFF
|                 |
|      Kernel     |
|                 |
|=================| <- 0xC0000000
|=================| <- 0xBFFFFFFF Stack (grows downwards) 
|                 | cli args and env vars at the bottom of stack
|      Stack      |
|                 |
|-----------------| <- Top of the stack
|                 |
|                 |
|=================| <-- 0x40000000 For shared libraries and mmap()
|                 |
|                 |
|-----------------| <-- Program break
|                 |
|      Heap       |
|                 |
|=================| <- Heap (grows upwards)
|                 |
|      Text       |
|                 |
|=================| <- 0x08048000
|                 |
|                 |
|=================| <- 0x00000000
Lower Addresses
```

<br>

Segments:
1. **Text segment** (aka **Code segment**). It contains instructions for CPU.
2. **Data segment**, it is divided into **two** parts:
- **initialized** data, it contains global and static variables that are initialized. Its not a read-only segment and hence the values can be modified;
- **uninitialized** data (aka **BSS** segment), data in this segment are initialized by the kernel to **0** before the program starts execution;
  - **uninitialized** data occupies no file space;
1. **Heap segment**.
2. **Stack segment**.
3. **Kernel segment**. It is mapped into process kernel memory, but **not** accessible to program, it contains process specific data (**pages**, ...).

<br>

Kernel segment is **kernel space** (1 GB). All other segments are **user space** (3 GB).<br>

<br>

**Program break** points to the address of **heap end**. When `malloc()` is called, it increases the **program break**.<br>

<br>

# ELF
The **ELF** (Executable and Linkable Format) is a common standard file format for **object files**: **executable files**, **libraries**, **core dumps**.<br>

The **ELF** files are composed of 3 major components:
- **ELF header**;
- **section header table** (used by linker);
- **segment header table** (aka **program header table**) (used by loader);

<br>

**Object files** participate in both **linking** and **execution**. The ELF file provides **two separate views** on the data inside the ELF file:
- **section view** for linker;
- **segment view** for loader;

<br>

Neither the **section header table** nor the **segment header table** have fixed positions, they can be located anywhere in an ELF file. 
To find them the ELF header is used, which is located at the very start of the file.

![elf_views](/img/elf_views.png)

<br>

## ELF Header
The **ELF header** is denoted by an `Elfxx_Ehdr` structure. Mainly, this contains general information about the binary.<br>

<br>

## ELF sections
**Sections** represent the smallest **indivisible units** that can be processed within an **ELF** file.<br>
**Sections** are used by linker at **compile time**.<br>
A **section header table** contains information about all sections in object file.<br>
**Every section** has an **entry** in the table. Each entry gives information such as the section **name**, the section **size**, and so forth.<br>

<br>

|Section|Meaning|
|:------|:------|
|`.interp`|This section contains the **full path** to the needed **dynamic loader**.|
|`.text`|This section holds the executable instructions for CPU.|
|`.rodata`|This section holds **read-only data**.|
|`.data`|This section holds **initialized** data.|
|`.bss`|For **uninitialized** data. The section occupies no file space.|
|`.note.ABI-tag`|This section specifies ABI details.|
|`.rela.*`|**Relocation** sections.|
|`.dynamic`|This section holds dynamic linking information.|
|`.dynsym`|This section holds the **symbol table** needed for **dynamic linking**.|
|`.dynstr`|This section holds **string table** needed for `.dynsym`.|
|`.symtab`|Contains a **symbol table**.|
|`.strtab`|Contains the **string table** for `.symtab`.|
|`.debug_info`|Contains information generated by compilers to describe the source code while debugging by keeping symbols and its type, scope, file, line number, etc.|
|`.debug_*`|Additional sections for debug info.|

<br>

### Initialization and termination Routines
Dynamic objects can supply code that provides for runtime **initialization** and **termination** processing.<br>
The **initialization code** is executed **once** each time the dynamic object is loaded in a process.<br>
The **termination code** is executed **once** each time the dynamic object is unloaded from a process or at process termination.<br>

If an *binary or library* contains both `.init` and `.init_array` sections, the `.init` section is processed **before** the `.init_array` section.<br>
If an *binary or library* contains both `.fini` and `.fini_array` sections, the `.fini_array` section is processed **before** the `.fini` section.<br>

<br>

### Relocation entries
**Relocation information** is held in **relocatable entries**, located in specific **relocation sections** within an ELF object.<br>
There are **two** different **relocation entry structures**: `Elfxx_Rel` and `Elfxx_Rela`.<br>
It is important to note that these relocation entry types are **mutually exclusive**. The reason for using one type of entry over the other, is usually architecture dependant. For example, in `x86` only `Elf32_Rel` is used, while on `x86_64` only `Elf64_Rela` is used.<br>

```c
typedef struct {
  Elf32_Addr r_offset;
  Elf32_Word r_info;
} Elf32_Rel;

typedef struct {
  Elf64_Addr   r_offset;
  Elf64_Xword  r_info;
  Elf64_Sxword r_addend;
} Elf64_Rela;
```

<br>

The only **difference** between both structures is that `Elfxx_Rela` contains additional field **relocation addend** used to compute the value to be stored into the relocatable field.

<br>

**Fields**:
- `r_offset` field contains the **offset** to **place** where **real address** must be **injected**, this is **reserved** and filled by zero.<br>
- `r_info` defines **type of addres** and **symbol table index** that defines symbol for which relocation is performed;
- `r_addend` specifies a **constant addend** used to compute the value to be stored into the relocatable field;

**Type of addres**:
-	`R_386_32`
-	`R_386_PC32`

<br>

## ELF segments
A **segment** ((aka **program header**)) comprises one or more **sections**, in other words, a **segment** is a **set** of **sections**.<br>
**Segments** are used by `exec(2)` or by the **dynamic linker** at loading time.<br>
A **segment header table** (aka **program header table**) contains information about all segments in object file.<br>
**Every segment** has an **entry** in the table. Each entry defines **access permissions** for segment and other info.<br>

<br>

# `readelf` command
A common tool to quickly parse ELF files is the `readelf` utility from **GNU binutils**.<br>
`readelf --file-header hello` shows **ELF headr**.<br>
`readelf --sections hello` prints out all **sections**.<br>
`readelf --segments hello` prints out all **segments** and section to segment **mapping**.<br>

<br>

**ELF Header**:
```bash
Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
Class:                             ELF64
Data:                              2's complement, little endian
Version:                           1 (current)
OS/ABI:                            UNIX - System V
ABI Version:                       0
Type:                              DYN (Position-Independent Executable file)
Machine:                           Advanced Micro Devices X86-64
Version:                           0x1
Entry point address:               0x1080
Start of program headers:          64 (bytes into file)
Start of section headers:          15328 (bytes into file)
Flags:                             0x0
Size of this header:               64 (bytes)
Size of program headers:           56 (bytes)
Number of program headers:         13
Size of section headers:           64 (bytes)
Number of section headers:         37
Section header string table index: 36
```

<br>

**Sections**:
```bash
.interp
.note.ABI-tag
.gnu.hash
.dynsym
.dynstr
.gnu.version
.rela.dyn
.rela.plt
.init
.plt
.plt.got
.plt.sec
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.dynamic
.got
.data
.bss
.comment
.debug_aranges
.debug_info
.debug_abbrev
.debug_line
.debug_str
.debug_line_str
.symtab
.strtab
.shstrtab
```

<br>

**Program Headers**:
```bash
Type           Offset             VirtAddr           PhysAddr
               FileSiz            MemSiz              Flags  Align
PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
               0x00000000000002d8 0x00000000000002d8  r      0x8
INTERP         0x0000000000000318 0x0000000000000318 0x0r00000000000318
               0x000000000000001c 0x000000000000001c  R      0x1
     [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
               0x0000000000000660 0x0000000000000660  R      0x1000
LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
               0x000000000000023d 0x000000000000023d  R E    0x1000
LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
               0x0000000000000164 0x0000000000000164  R      0x1000
LOAD           0x0000000000002db0 0x0000000000003db0 0x0000000000003db0
               0x000000000000029c 0x00000000000002f8  RW     0x1000
DYNAMIC        0x0000000000002dc0 0x0000000000003dc0 0x0000000000003dc0
               0x00000000000001f0 0x00000000000001f0  RW     0x8
NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
               0x0000000000000030 0x0000000000000030  R      0x8
NOTE           0x0000000000000368 0x0000000000000368 0x0000000000000368
               0x0000000000000044 0x0000000000000044  R      0x4
GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
               0x0000000000000030 0x0000000000000030  R      0x8
GNU_EH_FRAME   0x0000000000002030 0x0000000000002030 0x0000000000002030
               0x0000000000000044 0x0000000000000044  R      0x4
GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
               0x0000000000000000 0x0000000000000000  RW     0x10
GNU_RELRO      0x0000000000002db0 0x0000000000003db0 0x0000000000003db0
               0x0000000000000250 0x0000000000000250  R      0x1
```

<br>

> Note:<br>
> **Code segement** must have `RE` (**read** and **execute**) permission.<br>
> **Data segments** may have only `R` (**read**) permission or `RW` (**read** and **write**) permissions.<br>

<br>

**Section to segment mapping**:
```bash
Segment Sections...
00
01     .interp
02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt
03     .init .plt .plt.got .plt.sec .text .fini
04     .rodata .eh_frame_hdr .eh_frame
05     .init_array .fini_array .dynamic .got .data .bss
06     .dynamic
07     .note.gnu.property
08     .note.gnu.build-id .note.ABI-tag
09     .note.gnu.property
10     .eh_frame_hdr
11
12     .init_array .fini_array .dynamic .got
```

<br>

# `strip` command
To delete **symbol table** and **debug symbol** from object file there is special command: `strip`.<br>
The **debug symbol** is a special kind of symbol that attaches additional information to the symbol table.<br>

**Example**:
```bash
strip -s hello
```

<br>

**Options**:
- `-s`, `--strip-all` remove all symbols;
- `-d`, `--strip-debug` remove debugging symbols only;
- `-o <file>` put the stripped output in file `<file>`, rather than replacing the existing file;

# Table of contents
- [Table of contents](#table-of-contents)
- [Компиляция и компоновка](#компиляция-и-компоновка)
- [Linkage](#linkage)
- [Strip](#strip)
- [Библиотеки](#библиотеки)
  - [Статические библиотеки](#статические-библиотеки)
  - [Динамические библиотеки](#динамические-библиотеки)
- [libdl](#libdl)

<br>

# Компиляция и компоновка
**Компиляция** – процесс получения исполняемого файла из файлов исходного кода.<br>

Программа на С может состоять из множества отдельных файлов исходного кода. Для получения из отдельных файлов исходного кода единого исполняемого файла, к процессу компиляции добавляется этап компоновки.<br>

Компиляция выполняется в несколько этапов:
1.	Препроцессинг.
2.	Трансляция.
3.	Ассемблирование.
4.	Компоновка.

**Препроцессинг**: на этом этапе выполняется обработка всех директив препроцессора; файлы исходного кода с расширением `.c`, обработанные препроцессором, представляют собой единицы трансляции, которые за тем подаются на вход транслятора.<br>

**Трансляция**: на этом этапе каждая единица трансляции преобразуется в ассемблер соответствующей архитектуры.<br>

Единица трансляции (translation unit) – подаваемая на вход транслятора последовательность лексемм, каждая единица трансляции обрабатывается транслятором независимо от других.<br>

**Ассемблирование**: на этом этапе ассемблер преобразуется в машинный код, после чего создается **object file**.<br>

<br>

# Linkage
**Линковка** (компоновка) – процесс генерации исполняемого файла из **object files**; выполняется линковщиком.<br>

Этапы работы линковщика:
1.	Разрешение ссылок.
2.	Релокация.

<br>

Компилировать можно все файлы одновременно одной командой, перечисляя составные файлы через пробел после ключа `-c` (compile only, do **not** link):
```bash
gcc -c main.c f1.c f2.c
```

<br>

Или каждый файл в отдельности:
```bash
gcc -c f1.c
gcc -c f2.c
gcc -c main.c
```

В результате работы компилятора мы получим три отдельных объектных файла с расширением `.o`:
- `main.o`;
- `f1.o`;
- `f2.o`;

Чтобы их собрать в один файл с помощью gcc надо использовать ключ `-o <out_file>`, при этом линкер соберет все файлы в один:
```bash
gcc main.o f1.o f2.o -o rezult
```

<br>

# Strip
Любой компилятор по умолчанию снабжает объектный файл отладочной информацией.<br>
Компилятор `gcc` может создавать отладочную информацию в различных объемах и форматах (вплоть до номеров строк исходного текста), контролировать которые можно специальными ключами.
Для создания релизных бинарей существует отдельная программа, позволяющая удалить отладочную информацию из запускаемого файла. Называется эта программа `strip`.<br>
Для того, чтобы полностью очистить файл от отладочной информации, требуется вызвать ее с ключом `-s`:
```bash
strip -s a.out
```

<br>

# Библиотеки
Библиотеки по способу использования разделяются на два вида:
- статические библиотеки;
- динамические библиотеки;

<br>

**Статическая библиотека** - это **коллекция объектных файлов**, которые присоединяются к программе во время линковки программы. Таким образом статические библиотеки используются только при созданиии программы. Потом в работе самой программы они не принимают участие, в отличие от динамических библиотек.<br>

**Динамическая библиотека** - это созданная специальным образом библиотека, которая присоединяется к результирующей программе в два этапа:
- первый этап: **этап компиляции**. На этом этапе **линковщик** встраивает в программу описания требуемых функций и переменных, которые присутствуют в библиотеке. Сами объектные файлы из библиотеки не присоединяются к программе. 
- второй этап: непосредственно **этап запуска программы**. На этом этапе **системный динамический загрузчик** во время запуска программы выполняет релокацию и переасчет абсолютных адресов.

<br>

## Статические библиотеки
Для того, чтобы создать библиотеку с именем `NAME` из **объектых файлов** надо вызвать программу `ar` со следующими параметрами:
`ar rc libNAME.a [список объектых файлов]`:
- опция `c` (**create**) **создает** библиотеку, если ее нет;
- опция `r` (**replace**) **заменяет** старые объектные файлы новыми версиями;

<br>

Допустим наша библиотека будет называться `foo`, тогда команда примет вид:
```bash
ar rc libfoo.a f1.o f2.o
```

В результате получим файл `libfoo.a`, в котором будут лежать копии объектых файлов `f1.o` и `f2.o`.<br>


Чтобы из файла `libfoo.a` сделать **полноценную** статическую библиотеку объектных файлов надо добавить к этому архиву **индекс символов**, т.е. список вложенных в библиотеку функций и переменных, чтобы линковка происходила быстрее. Далается это командой `ranlib`: `ranlib libNAME.a`.<br>


Чтобы компилятор знал где искать библиотеки ему надо сообщить **каталог**, в котором они содержатся и **список билиотек**:
- **каталог с библиотеками** указывается ключом `-L`, в нашем случае библиотека находится в текущем каталоге, значит путь до нее будет в виде точки `-L.`;
- используемые **конкретные библиотеки** перечисляются через ключ `-l`, после которого указывается название библиотеки без префикса `lib` и окончания `.a`, например: `-lfoo`;

<br>

Команды:
```bash
gcc -c main.c
gcc main.o -L. -lfoo -o rezult
```

OR

```bash
gcc main.c -L. -lfoo -o rezult
```


Заметьте, что компилятору библиотеки нужны только на этапе **линковки**. Если мы попытаемся подсунуть библиотеку на этапе компиляции, то получим:
```bash
gcc -c main.c -L. -lfoo
gcc: -lfoo: linker input file unused since linking not done
```

<br>

## Динамические библиотеки
Объектный файл не подходит для динамических библиотек. Связано это с тем, что все объектные файлы создаваемые обычным образом не имеют представления о том в какие адреса памяти будет загружена использующая их программа. Несколько различных программ могут использовать одну библиотеку, и каждая из них располагается в различном адресном пространстве. Поэтому требуется, чтобы переходы в функциях библиотеки использовали не абсолютную адресацию, а относительную.
То есть генерируемый компилятором код должен быть независимым от адресов, такая технология называется **PIC** - **Position Independent Code**. В `gcc` данная возможность включается ключом `-fPIC`.<br>

<br>

Теперь компилирование наших файлов будет иметь вид:
```bash
gcc -fPIC -c f1.c
gcc -fPIC -c f2.c
```

<br>

**Динамическая библиотека** это уже не архивный файл, а настоящая **загружаемая программа**, поэтому созданием динамических библиотек занимается сам компилятор gcc. Для того, чтобы создать динамическую библиотеку надо использовать ключ `-shared`:
```bash
gcc -shared -o libfsdyn.so f1.o f2.o
```

<br>

В результате получим динамическую библиотеку `libfsdyn.so`.<br>

Теперь, чтобы компилировать результирующий файл с использованием динамической библиотеки нам надо собрать файл командой:
```bash
gcc -с main.с
gcc main.o -L. -lfsdyn -o rezultdyn
```

<br>

Для компоновки на этапе загрузки используется специальная программа – **динамический загрузчик**, в Linux это `/lib/ld-linux.so.x`. 

<br>

# libdl
Использовать динамические библиотеки можно не только в начале загрузки, но и в процессе самой работы программы. Программа сама может вызывать любые функции из библиотеки, когда ей захочется. Для этого всего-лишь надо использовать библиотеку `dl`, которая позволяет линковать библиотеки **на лету**. Она управляет загрузкой динамических библиотек, вызовом функций из них и выгрузкой после конца работы.<br>

Для использования функций программной работы с динамическими библиотеками необходимо подключить заголовочный файл:
```c
#include <dlfcn.h>
```

<br>

Чтобы вызывать какие-то функции из динамической библиотеки сначала надо открыть эту библиотеку функцией `dlopen`:
```c
void *dlopen (const char *filename, int flag);
```

Параметр `filename` содержит путь до требуемой библиотеки, а параметр `flag` задает некоторые специфические флаги для работы. Функция возвращает указатель на загруженную библиотеку.<br>

Пример:
```c
library_handler = dlopen("/path/to/the/library.so",RTLD_LAZY);
if (!library_handler){
	// если ошибка, то вывести ее на экран
	fprintf(stderr,"dlopen() error: %s\n", dlerror());
	exit(1); // в случае ошибки можно, например, закончить работу программы
};
```

<br>

После этого можно работать с библиотекой. А работа эта заключается в получении адреса требуемой функции из библиотеки. Получить адрес функции или переменной можно по ее имени с помощью функции `dlsym`:
```c
void *dlsym(void *handle, char *symbol);
```

<br>

Для этой функции требуется адрес загруженной библиотеки `handle`, полученный при открытии функцией `dlopen()`. Требуемая функция или переменная задается своим именем в переменной symbol.<br>

<br>

Закрывается библиотека функцией:
```c
dlclose(void *handle);
```

<br>
